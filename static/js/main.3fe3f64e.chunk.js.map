{"version":3,"sources":["api/giphyAPI.js","components/GifSearch.js","components/GifItem.js","components/GifRow.js","util/useBreakpoint.js","components/GifGrid.js","util/util.js","components/GifContainer.js","App.js","index.js"],"names":["instance","axios","create","baseURL","timeout","params","api_key","process","getGifs","limit","offset","endpoint","q","get","GifSearch","props","useState","input","setInput","autoComplete","setAutocomplete","autoCompleteSelected","setAutoCompleteSelected","autoCompleteRequest","setAutoCompleteRequest","containerInput","setContainerInput","gifResponse","setGifResponse","setOffset","styles","useEffect","getAutocompleteData","source","a","cancelToken","token","autocompleteData","data","console","log","message","CancelToken","timeOut","setTimeout","clearTimeout","resetAutocomplete","getSearchGifData","searchGifData","handleSubmit","cancel","debounceHandleSubmit","useCallback","debounce","InputGroup","className","FormControl","placeholder","value","onKeyDown","e","keyCode","length","name","onChange","target","Append","Button","variant","onClick","Row","style","position","zIndex","width","backgroundColor","Col","role","map","val","index","aria-selected","pagination","total_count","GifItem","gif","isLoaded","setIsLoaded","showInfo","setShowInfo","Placeholder","height","images","fixed_width","Spinner","top","left","animation","motion","div","initial","opacity","animate","whileHover","scale","whileTap","Card","Img","src","url","display","onLoad","alt","title","Body","listStyleType","padding","username","source_tld","Date","import_datetime","toLocaleDateString","id","GifRow","row","xs","md","lg","getDeviceConfig","useBreakpoint","window","innerWidth","brkPnt","setBrkPnt","calcInnerWidth","throttle","addEventListener","removeEventListener","GifGrid","gifs","loading","gifRows","setGifRows","breakpoint","forEach","push","mapGifsToRows","GifContainer","setGifs","setLoading","isBottom","setIsBottom","debounceIsBottom","handleScroll","bottom","innerHeight","scrollY","document","body","offsetHeight","res","getGifData","getMoreGifData","undefined","marginTop","marginBottom","App","Container","h1","y","transition","duration","type","stiffness","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.3fe3f64e.chunk.js","sourcesContent":["import axios from 'axios';\n\n/**\n * The axios instance for our giphy API calls.\n */\nconst instance = axios.create({\n    baseURL: 'https://api.giphy.com/v1/',\n    timeout: 30000,\n    params: {\n        api_key: process.env.REACT_APP_GIPHY_API_KEY\n    }\n});\n\n/**\n * \n * @param {number} limit The maximum number of objects to return.\n * @param {number} offset Specifies the starting position of the results.\n * @param {string} endpoint The endpoint for the GIPHY API.\n * @param {string} q Search query term or phrase.\n * @returns a response with a list of GIFs from the specified endpoint.\n */\nexport function getGifs(limit = 4, offset, endpoint = 'trending', q) {\n    if (endpoint === 'trending') {\n        return instance.get(`gifs/trending`, { params: { offset, limit, ...instance.params }});\n    }\n    else if (endpoint === ('search')) {\n        return instance.get(`gifs/search`, { params: { q, offset, limit, ...instance.params }})\n    }\n}\n\n/**\n * \n * @param {string} q Search query term or phrase.\n * @param {string} cancelToken The cancel token for the request, in case the request needs\n * to be canceled early.\n * @returns a response with a list of terms that completes the given tag on the GIPHY network.\n */\nexport function getAutocomplete(q, cancelToken) {\n    return instance.get(`gifs/search/tags`, { params: { q, ...instance.params }, cancelToken });\n}","import axios from 'axios';\nimport { useEffect, useState, useCallback } from 'react';\nimport { Row, Col, Button, InputGroup, FormControl } from 'react-bootstrap';\nimport { getAutocomplete, getGifs } from '../api/giphyAPI';\nimport { debounce } from 'lodash';\nimport './GifSearch.css'\n\n/**\n * Input component to search for GIFs.\n * @param {object} props\n * @param {function} props.containerInput State of the user input.\n * @param {function} props.setContainerInput State function to set the container input. \n * This is to show what the user searched for in the container. I was thinking of\n * potentially putting this in the GifSearch component, but ultimately thought it would be best\n * to separate them.\n * @param {object} props.gifResponse The full http response from GIPHY.\n * @param {function} props.setGifResponse State function to set the full http response from GIPHY.\n * @param {function} props.setOffset State function to set the offset of GIFs for the request.\n */\nexport default function GifSearch(props) {\n  // User input (real-time)\n  const [input, setInput] = useState('');\n\n  // AutoComplete data\n  const [autoComplete, setAutocomplete] = useState();\n\n  // Array index of which AutoComplete suggestion is selected (-1 for none)\n  const [autoCompleteSelected, setAutoCompleteSelected] = useState(-1);\n\n  // The full AutoComplete rquest\n  const [autoCompleteRequest, setAutoCompleteRequest] = useState();\n\n  // The container's input (after user search)\n  const [containerInput, setContainerInput] = [props.containerInput, props.setContainerInput];\n\n  // Full GIPHY response\n  const [gifResponse, setGifResponse] = [props.gifResponse, props.setGifResponse];\n\n  const setOffset = props.setOffset\n\n  const styles = {\n    autoComplete: 'autoComplete',\n    autoCompleteItem: 'autoCompleteItem py-2',\n    autoCompleteText: 'autoCompleteText'\n  };\n\n  /**\n   * useEffect to grab autocomplete data if the user types something\n   */\n  useEffect(() => {\n\n    if (input !== '') {\n      const getAutocompleteData = async (source) => {\n        try {\n          const autocompleteData = await getAutocomplete(input, source.token);\n          setAutocomplete(autocompleteData.data.data);\n        }\n        catch (e) {\n          console.log(e.message);\n        }\n      }\n      // We create a cancel token in axios that we pass to the\n      // request in case we need to cancel the request when the\n      // user searches before auto complete data has been returned.\n      const newCancelToken = axios.CancelToken;\n      const source = newCancelToken.source();\n      setAutoCompleteRequest(source);\n\n      // Debounce auto complete request by 1 second so then the server doesn't\n      // get overloaded.\n      const timeOut = setTimeout(() => getAutocompleteData(source), 1000);\n      return () => clearTimeout(timeOut);\n    }\n    else {\n      resetAutocomplete();\n    }\n  }, [input])\n\n  /**\n   * Asynchronous call to get search gif data, map to\n   * gif rows, and then set the gif array.\n   */\n  const getSearchGifData = async () => {\n    if (input === '') {\n      const searchGifData = await getGifs(48, 0);\n      setGifResponse(searchGifData.data);\n    }\n    else {\n      const searchGifData = await getGifs(48, 0, 'search', input);\n      setGifResponse(searchGifData.data);\n    }\n    // Reset offset if searching for something new.\n    setOffset(48);\n  }\n\n  const handleKeydown = (e) => {\n    if (autoComplete) {\n      // Arrow key down\n      if (e.keyCode === 40 && autoCompleteSelected < autoComplete.length - 1) {\n        setAutoCompleteSelected(autoCompleteSelected + 1);\n      }\n      // Arrow key up\n      else if (e.keyCode === 38 && autoCompleteSelected > -1) {\n        setAutoCompleteSelected(autoCompleteSelected - 1);\n      }\n      // Enter\n      else if (e.keyCode === 13) {\n\n        // If the user presses enter to select an auto complete suggestion.\n        if (autoCompleteSelected > -1) {\n          setInput(autoComplete[autoCompleteSelected].name);\n          resetAutocomplete();\n        }\n\n        // The user pressed enter to search their input.\n        else {\n          handleSubmit();\n        }\n      }\n    }\n\n    // If the user has no auto complete suggestions (either the request is still\n    // pending or there are no results), and presses enter to submit their input.\n    else if (e.keyCode === 13) {\n      handleSubmit();\n    }\n\n\n  }\n\n  /**\n   * Function to reset auto complete state\n   * variables.\n   */\n  const resetAutocomplete = () => {\n    setAutocomplete(null);\n    setAutoCompleteSelected(-1);\n  }\n\n  /**\n   * Function to handle when a user wants to search GIFs.\n   */\n  const handleSubmit = () => {\n    // Don't send another request if the input is the same as the previous request.\n    if (input !== containerInput) {\n      // We always want to immediately cancel the auto complete request if a user tries to submit\n      // so we omit it from the debounce.\n      if (autoCompleteRequest) {\n        autoCompleteRequest.cancel('Canceled autocomplete request because user searched.');\n      }\n      debounceHandleSubmit();\n    }\n  }\n\n  /**\n   * The rest of handleSubmit that we want to debounce.\n   */\n  const handleSubmitRest = () => {\n    getSearchGifData();\n    resetAutocomplete();\n    setContainerInput(input);\n  }\n\n  // Callback for handleSubmit debounce. Dependency arry includes input (so that the\n  // search query doesn't become stale)\n  const debounceHandleSubmit = useCallback(debounce(handleSubmitRest, 500), [input]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return (\n    <div>\n      <InputGroup className=\"mb-3\">\n        <FormControl\n          placeholder=\"Search for something!\"\n          value={input}\n          onKeyDown={handleKeydown}\n          onChange={(e) => {\n            setInput(e.target.value)\n          }} />\n        <InputGroup.Append>\n          <Button variant=\"light\" onClick={() => { handleSubmit(); }}>Search!</Button>\n        </InputGroup.Append>\n        {autoComplete && autoComplete.length > 0 &&\n          <Row className='text-light rounded mx-0 mt-5' style={{ position: 'absolute', zIndex: 10, width: 'inherit', backgroundColor: 'rgba(0, 0, 0, 0.5' }}>\n            <Col className='pt-2 px-0'>\n              <ul className={styles.autoComplete} role='listbox'>\n                {autoComplete.map((val, index) => {\n                  return <li className={styles.autoCompleteItem} key={index} aria-selected={autoCompleteSelected === index} role='option' onClick={() => {\n                    setInput(val.name);\n                    resetAutocomplete();\n                  }}>\n                    <div className={styles.autoCompleteText}>{val.name}</div>\n                  </li>\n                })}\n              </ul>\n            </Col>\n          </Row>}\n      </InputGroup>\n      <h3\n        className='text-light'><strong>{containerInput ? containerInput : 'trending'}</strong></h3>\n      { gifResponse &&\n        <h5 className='text-secondary'>{gifResponse.pagination.total_count ? gifResponse.pagination.total_count + ' GIFs found.' : ''}</h5>}\n    </div>\n  )\n}","import { useState } from 'react';\nimport { Card, Spinner } from 'react-bootstrap';\nimport { motion } from 'framer-motion';\n\n/**\n * A GIF item. Just a Card with some animation.\n * The GifItem also makes sure images have been loaded before displaying.\n * @param {object} props \n * @param {object} props.gif A GIF.\n */\nexport default function GifItem(props) {\n\n    const gif = props.gif;\n    const [isLoaded, setIsLoaded] = useState(false);\n    const [showInfo, setShowInfo] = useState(false);\n\n    // Placeholder for GifItem when image is still loading.\n    const Placeholder = () => {\n        return (\n            <div style={{ height: `${gif.images.fixed_width.height}px`, width: '100%' }}>\n                <Spinner style={{ position: 'relative', top: '40%', left: '45%' }} animation='border' />\n            </div>\n        )\n    }\n\n\n    return (\n        <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            whileHover={{ scale: 1.2 }}\n            whileTap={{ scale: 1 }}\n            onClick={() => { setShowInfo(!showInfo) }}\n        >\n            <Card key={gif.id}>\n                {!showInfo && <Card.Img src={gif.images.fixed_width.url} style={isLoaded ? {} : { display: 'none' }} onLoad={() => setIsLoaded(true)} alt={gif.title} />}\n                {!showInfo && !isLoaded && <Placeholder />}\n                {showInfo && <Card.Body>\n                    <h6><small>{gif.title}</small></h6>\n                    <ul style={{ listStyleType: 'none', padding: 0 }}>\n                        <li>\n                            <small className='text-muted'>user - {gif.username ? gif.username : 'None'}</small>\n                        </li>\n                        <li>\n                            {gif.source_tld && <small className='text-muted'>{gif.source_tld}</small>}\n                        </li>\n                        <li>\n                            {<small className='text-muted'>{new Date(gif.import_datetime).toLocaleDateString('en-us')}</small>}\n                        </li>\n                    </ul>\n                </Card.Body>}\n\n            </Card>\n        </motion.div>\n    )\n\n}","import { Row, Col } from 'react-bootstrap';\nimport GifItem from './GifItem';\n\n/**\n * A row of GIFs, which maps its values to GifItems.\n * @param {object} props \n * @param {object} props.row A row of GIFs\n */\nexport default function GifRow(props) {\n\n  const row = props.row;\n  \n  return (\n    <Row className='pb-3'>{\n      row.map((gif, index) => {\n        return (\n          <Col xs={6} md={3} lg={2} key={index}>\n            <GifItem gif={gif} />\n          </Col>\n        )\n      })}\n    </Row>\n  )\n}","import { useState, useEffect } from 'react';\nimport { throttle } from 'lodash';\n\n/**\n * \n * @param {number} width Width of the screen\n * @returns a string of the current breakpoint\n */\nconst getDeviceConfig = (width) => {\n    if (width < 320) {\n        return 'xs';\n    } else if (width >= 320 && width < 720) {\n        return 'sm';\n    } else if (width >= 720 && width < 1024) {\n        return 'md';\n    } else if (width >= 1024) {\n        return 'lg';\n    }\n};\n\n/**\n * Custom hook to return breakpoints of the window. Credits to:\n * https://betterprogramming.pub/usebreakpoint-hook-get-media-query-breakpoints-in-react-3f1779b73568\n * @returns the name of the breakpoint the browser is at.\n */\nconst useBreakpoint = () => {\n    const [brkPnt, setBrkPnt] = useState(() => getDeviceConfig(window.innerWidth));\n\n    useEffect(() => {\n        const calcInnerWidth = throttle(function () {\n            setBrkPnt(getDeviceConfig(window.innerWidth))\n        }, 200);\n        window.addEventListener('resize', calcInnerWidth);\n        return () => window.removeEventListener('resize', calcInnerWidth);\n    }, []);\n\n    return brkPnt;\n}\nexport default useBreakpoint;","import { useEffect, useState } from 'react';\nimport { Spinner } from 'react-bootstrap';\nimport { mapGifsToRows } from '../util/util';\nimport GifRow from './GifRow';\nimport useBreakpoint from '../util/useBreakpoint';\n\n/**\n * A grid for strictly displaying GIFs. Uses GridRow.\n * Takes a loading prop in case the request hasn't been resolved yet.\n * @param {object} props \n * @param {object} props.gifs An array of rows of GIFs\n * @param {string} props.input User input\n * @param {boolean} props.loading A boolean denoting if the component is loading or not\n */\nexport default function GifGrid(props) {\n    const input = props.input;\n    const gifs = props.gifs;\n    const loading = props.loading;\n\n    const [gifRows, setGifRows] = useState([]);\n\n    const breakpoint = useBreakpoint();\n\n    // map the GIFs to rows\n    useEffect(() => {\n        setGifRows(mapGifsToRows(gifs, breakpoint));\n    }, [gifs, breakpoint])\n\n    if (gifRows.length) {\n        return (\n            <div className='py-2'>\n                {\n                    gifRows.map((row, index) => {\n                        return (\n                            <GifRow row={row} key={index} />\n                        )\n                    })}\n            </div>\n\n        )\n    }\n\n    else if (loading) {\n        return (\n            <div className='py-2'>\n                <Spinner animation='border' />\n            </div>\n        )\n    }\n\n    return (\n        <div className='py-2'>\n            <h5>No GIFs found for {input}.</h5>\n        </div>\n    );\n\n}","/**\n * Function that maps an array of gifs to rows of 4.\n * @param {object} gifs An array of gifs.\n * @returns an array of arrays with four gifs in each subarray.\n */\n export const mapGifsToRows = (gifs, breakpoint) => {\n  let div = 4;\n  \n  if (breakpoint === 'xs' || breakpoint === 'sm') {\n    div = 2;\n  }\n  if (breakpoint ==='lg') {\n    div = 6;\n  }\n  let gifRows = [];\n  let row = [];\n  gifs.forEach((gif, index) => {\n    if ((index + 1) % div === 0 || index === gifs.length - 1) {\n      row.push(gif);\n      gifRows.push(row);\n      row = []\n    }\n    else {\n      row.push(gif);\n    }\n  })\n\n  return gifRows;\n}","import { useEffect, useState, useCallback } from 'react';\nimport { getGifs } from '../api/giphyAPI';\nimport { Row, Col } from 'react-bootstrap';\nimport GifSearch from './GifSearch';\nimport GifGrid from './GifGrid';\nimport { debounce } from 'lodash';\n\n/**\n * Container for GIFs. This is the top level component which contains the state of\n * the GIF data and sends it down to its children.\n */\nexport default function GifContainer() {\n\n  // User input (after hitting submit)\n  const [input, setInput] = useState('');\n\n  // Array of GIFs\n  const [gifs, setGifs] = useState([]);\n\n  // Full GIF response\n  const [gifResponse, setGifResponse] = useState();\n\n  // Loading state for GifGrid\n  const [loading, setLoading] = useState(true);\n\n  // Offset for additional requests afterwards if user scrolls down\n  const [offset, setOffset] = useState(48);\n\n  // True if user is at the bottom of the screen\n  const [isBottom, setIsBottom] = useState(false);\n\n  const debounceIsBottom = useCallback(debounce(setIsBottom, 1000), []); // eslint-disable-line react-hooks/exhaustive-deps\n  /**\n   * Sets isBottom boolean to true or false if the user is at the bottom of the\n   * page.\n   */\n  const handleScroll = () => {\n    const bottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight\n    if (bottom !== isBottom) {\n      debounceIsBottom(bottom);\n    }\n  };\n\n  /**\n   * On Mount useEffect.\n   */\n  useEffect(() => {\n    // Get initial gif data\n    const getGifData = async () => {\n      try {\n        setLoading(true);\n        const res = await getGifs(48, 0);\n        setGifResponse(res.data);\n        setGifs(res.data.data);\n        setLoading(false);\n      }\n      catch (e) {\n        console.log(e.message);\n      }\n    }\n    getGifData();\n\n    // Add listener for scroll (infinite scrolling)\n    window.addEventListener('scroll', handleScroll);\n    return () => {\n      document.removeEventListener('scroll', handleScroll);\n    }\n    // Disabled react-hooks/exhaustive-deps (eventListener function does not change)\n    // eslint-disable-next-line\n  }, []);\n\n  // Infinite scroll\n  useEffect(() => {\n    // Make sure that there's still GIFs to load before sending the request.\n    if (isBottom && offset < gifResponse.pagination.total_count) {\n      const getMoreGifData = async () => {\n        // Await GIFs (if input is blank, search from trending, otherwise use query)\n        try {\n          const res = await getGifs(12, offset, input ? 'search' : 'trending', input ? input : undefined);\n          setGifs((gifs) => {\n            return ([...gifs, ...res.data.data]);\n          });\n\n          setOffset((offset) => (offset + 12));\n        }\n        catch (e) {\n          console.log(e.message);\n        }\n      }\n      setIsBottom(false);\n      getMoreGifData();\n    }\n  }, [gifResponse, isBottom, offset, input]);\n\n  // If the gifResponse gets modified (ex. typically when the user tries to search for something new), we will\n  // need to map the new values to the state.\n  useEffect(() => {\n    if (gifResponse) {\n      setGifs(gifResponse.data);\n    }\n  }, [gifResponse]);\n\n  return (\n    <div>\n      <GifSearch containerInput={input} setContainerInput={setInput} gifResponse={gifResponse} setGifResponse={setGifResponse} setOffset={setOffset} />\n      <GifGrid gifs={gifs} input={input} loading={loading} />\n      {/* We check offset & total count in case there are no more records */}\n      {offset < (gifResponse ? gifResponse.pagination.total_count : 0) &&\n        <Row style={{ marginTop: '10em', marginBottom: '10em' }}>\n          <Col className='text-center'>\n            <h1>...</h1>\n          </Col>\n        </Row>\n      }\n    </div>\n  )\n\n}\n","import React from 'react';\nimport { Container } from 'react-bootstrap';\nimport { motion } from 'framer-motion';\nimport GifContainer from './components/GifContainer';\n\nfunction App() {\n\n  return (\n    <Container>\n      <div className='py-5'>\n        <motion.h1\n          initial={{ y: -200, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ duration: 1.5, type: \"spring\", stiffness: 100 }}\n        >Giphy Search Clone ðŸŽ‡</motion.h1>\n        <h5\n          className='text-secondary'>Click a GIF to show some more info!</h5>\n      </div>\n      <GifContainer />\n    </Container>\n  )\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport 'bootswatch/dist/darkly/bootstrap.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}